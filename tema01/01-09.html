<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programación de Procesos</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/vs2015.min.css">
</head>

<body>
    <header class="header">
        <div class="header-content">
            <div class="logo">Programación de Procesos</div>
        </div>
    </header>

    <div class="container">
        <main class="main-content">
            <div class="content-header">
                <h1 class="content-title">1.9. Concurrencia en Java</h1>
            </div>

            <div class="lesson-section">

                <p class="text-content">La máquina virtual de Java, el lenguaje Java y la biblioteca de clases estándar
                    de Java se han diseñado para soportar programación concurrente.</p>

                <p class="text-content">La funcionalidad básica para procesos la proporciona la clase
                    <code>Process</code>.
                </p>

                <p class="text-content">La funcionalidad básica para hilos la proporciona la clase <code>Thread</code>.
                    Esta clase implementa la interfaz <code>Runnable</code>.</p>

                <p class="text-content">El paquete <code>java.util.concurrent</code> proporciona funcionalidad de alto
                    nivel para programación concurrente. Incluye varios <em>frameworks</em> y algunas clases
                    adicionales.</p>

                <p class="text-content">El resto de este capítulo se dedica a los procesos. El siguiente capítulo se
                    dedica a los hilos (<em>threads</em>).</p>

                <p class="text-content">La clase <code>Process</code> es abstracta y, por lo tanto, no se pueden crear
                    objetos de ella, sino de subclases suyas, que, de hecho, implementan procesos nativos, es decir,
                    procesos de plataformas específicas que se ejecutan en un sistema operativo particular para un tipo
                    de procesador particular. La clase <code>Process</code> tiene métodos para lanzar un proceso,
                    obtener información acerca de su estado y controlar su ejecución.</p>

                <p class="text-content">Se pueden crear objetos de la clase <code>Process</code> con métodos de otras
                    clases, en particular con <code>ProcessBuilder.start()</code> y <code>Runtime.exec()</code>.</p>

                <h3 class="section-title">1.9.1. La clase Runtime</h3>

                <p class="text-content">Cada programa de Java tiene asociada una instancia de la clase
                    <code>Runtime</code> que le permite obtener información del entorno de ejecución e interactuar con
                    él. Esta se puede recuperar con el método estático <code>getRuntime()</code>. Las diversas variantes
                    del método <code>exec()</code> permiten lanzar nuevos procesos.
                </p>

                <p class="text-content">En el cuadro 1.2 se muestran algunos de los métodos de esta clase.</p>

                <div class="table-container">
                    <h4 class="table-title">Cuadro 1.2 - Métodos de la clase Runtime</h4>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Método</th>
                                <th>Funcionalidad</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>static Runtime getRuntime()</code></td>
                                <td>Devuelve el objeto <code>Runtime</code> asociado con la aplicación de Java actual.
                                </td>
                            </tr>
                            <tr>
                                <td><code>Process exec(String command)</code><br>
                                    <code>Process exec(String[]</code><br>
                                    <code>comandYArgs)</code><br><code>Process exec(String[]</code><br>
                                    <code>comandYArgs, String[] envp)</code><br>
                                    <code>Process exec(String[] cmdarray,</code><br>
                                    <code>String[] envp, File dir)</code>
                                </td>
                                <td>Ejecuta un comando. Algunas variantes permiten especificar el entorno de ejecución y
                                    el directorio para ejecutar el comando.</td>
                            </tr>
                            <tr>
                                <td><code>void exit(int status)</code><br>
                                    <code>void halt(int status)</code>
                                </td>
                                <td>Termina la ejecución de la máquina virtual. El primer método lo hace de manera
                                    ordenada, y el segundo, de manera abrupta.</td>
                            </tr>
                            <tr>
                                <td><code>int availableProcessors()</code></td>
                                <td>Devuelve el número de procesadores disponibles para la máquina virtual de Java.</td>
                            </tr>
                            <tr>
                                <td><code>long freeMemory()</code></td>
                                <td>Devuelve la cantidad de memoria disponible para la máquina virtual.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3 class="section-title">1.9.2. Las clases Process y ProcessBuilder</h3>

                <p class="text-content"><code>Process</code> es una clase abstracta. Se pueden obtener instancias de
                    subclases suyas que proporcionan implementaciones para una plataforma particular, con métodos de la
                    clase <code>ProcessBuilder</code>.</p>

                <p class="text-content">Con <code>ProcessBuilder</code> se puede configurar previamente el entorno de
                    ejecución de los procesos que crea y, en particular, como se verá en breve, redirigir su entrada y
                    salida. En el cuadro 1.3 se muestran algunos de sus métodos.</p>

                <div class="table-container">
                    <h4 class="table-title">Cuadro 1.3 - Métodos de la clase ProcessBuilder</h4>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Método</th>
                                <th>Funcionalidad</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>ProcessBuilder(String comando)</code><br>
                                    <code>ProcessBuilder(List&lt;String&gt;</code><br>
                                    <code>comando)</code>
                                </td>
                                <td>Construye un <code>ProcessBuilder</code> para un comando con los correspondientes
                                    argumentos de línea de comandos, en su caso.</td>
                            </tr>
                            <tr>
                                <td><code>ProcessBuilder directory(File</code><br>
                                    <code>directorio)</code><br>
                                    <code>File directory()</code>
                                </td>
                                <td>El primer método establece el directorio de trabajo del proceso, y el segundo método
                                    lo devuelve. Por defecto, el segundo método normalmente devuelve <code>null</code>.
                                    Si es así, se puede obtener el directorio de ejecución del proceso actual con
                                    <code>System.getProperty("user.dir")</code>.
                                </td>
                            </tr>
                            <tr>
                                <td><code>Map&lt;String,String&gt;</code><br>
                                    <code>environment()</code>
                                </td>
                                <td>Devuelve el entorno de trabajo del proceso, que es una lista de asignación de
                                    valores para variables de entorno.</td>
                            </tr>
                            <tr>
                                <td><code>Process start()</code></td>
                                <td>Crea e inicia un proceso.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <p class="text-content">El cuadro 1.4 muestra los principales métodos de la clase Process.</p>

                <div class="table-container">
                    <h4 class="table-title">Cuadro 1.4 - Métodos de la clase Process</h4>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Método</th>
                                <th>Funcionalidad</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>void destroy()</code><br>
                                    <code>public Process</code><br>
                                    <code>destroyForcibly()</code>
                                </td>
                                <td>Termina el proceso. El primer método permite una terminación limpia y ordenada del
                                    proceso. El segundo lo termina inmediatamente.</td>
                            </tr>
                            <tr>
                                <td><code>int exitValue()</code></td>
                                <td>Devuelve el valor de salida, o código de retorno, del proceso. Por convención, un
                                    valor 0 indica terminación normal, y otro valor se interpretará como un código de
                                    error. Se puede terminar un programa en Java con un código de retorno distinto de 0
                                    con <code>System.exit(código)</code>.</td>
                            </tr>
                            <tr>
                                <td><code>ProcessHandle.Info info()</code></td>
                                <td>Devuelve la información actual del proceso.</td>
                            </tr>
                            <tr>
                                <td><code>boolean isAlive()</code></td>
                                <td>Comprueba si el proceso está vivo.</td>
                            </tr>
                            <tr>
                                <td><code>long pid()</code></td>
                                <td>Devuelve el PID o identificador de proceso.</td>
                            </tr>
                            <tr>
                                <td><code>int waitFor()</code></td>
                                <td>Hace que el hilo en ejecución espere hasta que el proceso haya terminado. Devuelve
                                    el valor de salida del proceso. Un valor cero se entiende que corresponde a una
                                    ejecución sin errores, mientras que un valor distinto de cero corresponde a un
                                    código de error. Si el proceso es de un programa en Java, es el valor devuelto por
                                    <code>System.exit()</code>, o cero si no se terminó la ejecución con
                                    <code>System.exit()</code>.
                                </td>
                            </tr>
                            <tr>
                                <td><code>boolean waitFor(long</code><br>
                                    <code>timeout,</code><br>
                                    <code>TimeUnit unit)</code>
                                </td>
                                <td>Hace que el hilo en ejecución espere hasta que el proceso haya terminado, durante un
                                    tiempo máximo indicado por <code>timeout</code>. Devuelve <code>true</code> si el
                                    proceso ha terminado por sí mismo antes del tiempo máximo indicado, y
                                    <code>false</code> en caso contrario.
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <p class="text-content">Cualquiera de los múltiples errores que se pueden producir durante la creación y
                    ejecución del proceso hará que se produzca una excepción, en general, de la clase
                    <code>IOException</code>.
                </p>

                <p class="text-content">El siguiente programa de ejemplo crea un proceso para un comando que se pasa
                    como parámetros de línea de comandos en args. Estos se pasan directamente al creador de
                    <code>ProcessBuilder</code> con <code>ProcessBuilder(args)</code>. La llamada a
                    <code>inheritIO()</code> hace que el proceso herede la entrada y salida estándares del proceso
                    padre. Con <code>waitFor()</code> se espera a que termine la ejecución del proceso hijo y se obtiene
                    el código de retorno. Si, mientras eso sucede, se interrumpe la ejecución del programa, se lanzaría
                    una excepción de tipo <code>InterruptedException</code>, que este programa capturaría, y de la que
                    informaría.
                </p>
                <div class="code-container">
                    <div class="code-header">
                        <span>Lanzador de procesos</span>
                        <span class="language-badge">java</span>
                    </div>
                    <div class="code-content">
                        <button class="copy-button">Copiar</button>
                        <pre><code>import java.util.Arrays;
import java.io.IOException;

public class LanzaProceso {

  public static void main(String[] args) {

    if (args.length <= 0) {
      System.out.println("Debe indicarse comando a ejecutar.");
      System.exit(1);
    }

    ProcessBuilder pb = new ProcessBuilder(args);
    pb.inheritIO();

    try {
      Process p = pb.start();
      int codRet = p.waitFor();
      System.out.println("La ejecución de " + Arrays.toString(args)
              + " devuelve " + codRet
              + " " + (codRet == 0 ? "(ejecución correcta)" : "(ERROR)")
      );
    } catch (IOException e) {
      System.err.println("Error durante ejecución del proceso");
      System.err.println("Información detallada");
      System.err.println("---------------------");
      e.printStackTrace();
      System.err.println("---------------------");
      System.exit(2);
    } catch (InterruptedException e) {
      System.err.println("Proceso interrumpido");
      System.exit(3);
    }
  }
}</code></pre>
                    </div>
                </div>
                <h3 class="section-title">1.9.3. Redirección de entrada y salida estándares y de error</h3>

                <p class="text-content">Las clases <code>ProcessBuilder</code> y <code>Process</code> proporcionan
                    diversos mecanismos para redireccionar y gestionar la salida y entrada de los procesos. Esto podría
                    no funcionar bien en algunas plataformas, debido a limitaciones en los buffers utilizados para ellas
                    por el sistema operativo particular. Estos mecanismos se aprovechan en algunos de los programas de
                    ejemplo que se presentan a continuación.</p>

                <div class="info-box note">
                    <div class="info-box-title">RECUERDA</div>
                    <p>Los conceptos de entrada y salida estándares y de salida de error se introdujeron en el sistema
                        operativo UNIX, y se implementaron posteriormente en Linux y Windows. Cualquier proceso tiene
                        acceso a varios <em>streams</em> o flujos de bytes.</p>

                    <img src="image01-09.png" alt="" class="responsive-image">

                    <ul>
                        <li><strong>Entrada estándar o stdin (standard input)</strong>. Es un <em>stream</em> de entrada
                            del que puede leer datos. Normalmente, se lean datos sobre los que se realiza algún
                            procesamiento. Por defecto, suele estar asociada al teclado, de manera que el programa puede
                            leer de teclado el texto que se introduce por teclado.</li>
                        <li><strong>Salida estándar o stdout (standard output)</strong>. Es un <em>stream</em> de salida
                            en el que se pueden escribir datos. Una manera sencilla en que un programa puede generar su
                            salida es escribirla en la salida estándar. Por defecto, suele estar asociada a la pantalla,
                            de manera que todo el texto que se envía a la salida estándar se escribe en la pantalla.
                        </li>
                        <li><strong>Salida de error o stderr (standard output)</strong>. Es un <em>stream</em> de salida
                            en el que se pueden escribir datos. También suele estar asociado a la pantalla, de manera
                            que todo el texto que se envía a la salida de error se escribe en la pantalla.</li>
                    </ul>

                    <p>El proceso puede ser cualquier programa en ejecución. Para los siguientes ejemplos se utilizarán
                        comandos existentes en Linux.</p>

                    <p>Existen mecanismos de redirección para estos <em>streams</em> muy potentes y versátiles, que se
                        detallan a continuación, y para los que se ponen ejemplos.</p>

                    <div class="table-container">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>Fichero</th>
                                    <th>Ejemplo</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>A entrada estándar desde</td>
                                    <td><code>proceso &lt; fichero</code></td>
                                    <td><code>grep localhost &lt; /etc/hosts</code></td>
                                </tr>
                                <tr>
                                    <td>De salida estándar hacia</td>
                                    <td><code>proceso &gt; fichero</code><br><code>proceso &gt;&gt; fichero</code></td>
                                    <td><code>ls -l &gt; listafich.txt</code><br><code>echo -dn- &gt;&gt; listafich.txt</code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>De salida de error hacia</td>
                                    <td><code>proceso 2&gt; fichero</code><br><code>proceso 2&gt;&gt; fichero</code>
                                    </td>
                                    <td><code>ls /et 2&gt; errores.log</code><br><code>ls /etcaetera 2&gt;&gt; errores.log</code>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <p class="table-note">(Nota: Para descartar salida, se puede redirigir a <code>/dev/null</code>)
                        </p>
                    </div>

                    <div class="table-container">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th colspan="2">Ejemplo</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>De salida estándar de un proceso a entrada estándar de otro</td>
                                    <td><code>proceso1 | proceso2</code></td>
                                    <td><code>head -4 /etc/fstab | tail -1</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <h4 class="section-title">A) Mecanismos de redirección de la clase ProcessBuilder</h4>

                <p class="text-content">La clase <code>ProcessBuilder</code> proporciona mecanismos para la redirección
                    de la entrada y salida de los nuevos procesos creados. En los programas de ejemplo vistos hasta
                    ahora, se ha utilizado el método <code>inheritIO()</code> para enlazar la entrada y la salida
                    estándares y de error de los subprocesos con las del proceso principal, y por eso se ha podido ver
                    su salida.</p>

                <p class="text-content">Los mecanismos proporcionados por <code>ProcessBuilder</code> para ello son los
                    siguientes:</p>

                <ol class="text-content">
                    <li>El método <code>inheritIO()</code>. Esta es la solución más sencilla y la utilizada en el
                        programa anterior. Con este método, la entrada y la salida estándares y de error de los procesos
                        creados se enlazan con las del proceso padre actual.</li>
                    <li>Los métodos <code>redirectInput()</code>, <code>redirectOutput()</code> y
                        <code>redirectError()</code> son útiles cuando se necesita una sencilla redirección, desde o
                        hacia un fichero, o bien a <code>/dev/null</code> para ignorar la salida.
                    </li>
                </ol>

                <ul class="text-content">
                    <li><code>redirectInput()</code> redirige la entrada desde:
                        <ul>
                            <li>La entrada estándar del proceso padre con <code>redirect.INHERIT</code>.</li>
                            <li>El contenido de un fichero con un objeto <code>File</code>.</li>
                        </ul>
                    </li>
                    <li><code>redirectOutput()</code> redirige la salida estándar de los nuevos procesos creados hacia:
                        <ul>
                            <li>La salida estándar del proceso padre con <code>redirect.INHERIT</code>.</li>
                            <li>Un fichero, borrando contenido actual del fichero con <code>f</code>, de clase
                                <code>File</code>.
                            </li>
                            <li>Un fichero, añadiendo a sus contenidos actuales con <code>Redirect.appendTo(f)</code>.
                            </li>
                            <li>Ninguna parte, con lo que se descarta sin más con <code>Redirect.DISCARD</code>.</li>
                        </ul>
                    </li>
                    <li><code>redirectError()</code> funciona como <code>redirectOutput()</code>, pero para la salida de
                        error.</li>
                </ul>

                <p class="text-content">El cuadro 1.5 muestra la equivalencia entre los diversos métodos de redirección
                    para la clase <code>ProcessBuilder</code> de Java y mecanismos de redirección disponibles para la
                    ejecución de comandos en una <em>shell</em> de Linux.</p>

                <div class="table-container">
                    <h4 class="table-title">Cuadro 1.5 - Métodos de redirección para clase ProcessBuilder de Java</h4>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Métodos</th>
                                <th>Línea de comandos de Linux</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>redirectInput(new File (fichero))</code></td>
                                <td><code>comando &lt; fichero</code></td>
                            </tr>
                            <tr>
                                <td><code>redirectOutput(new File(fichero))</code></td>
                                <td><code>comando &gt; fichero</code></td>
                            </tr>
                            <tr>
                                <td><code>redirectOutput(Redirect.appendTo(new File(fichero)))</code></td>
                                <td><code>comando &gt;&gt; fichero</code></td>
                            </tr>
                            <tr>
                                <td><code>redirectOutput(Redirect.DISCARD)</code></td>
                                <td><code>comando &gt; /dev/null</code></td>
                            </tr>
                            <tr>
                                <td><code>redirectError(new File(fichero))</code></td>
                                <td><code>comando 2&gt; fichero</code></td>
                            </tr>
                            <tr>
                                <td><code>RedirectError(Redirect.appendTo(new File(fichero)))</code></td>
                                <td><code>comando 2&gt;&gt; fichero</code></td>
                            </tr>
                            <tr>
                                <td><code>redirectError(Redirect.DISCARD)</code></td>
                                <td><code>comando 2&gt; /dev/null</code></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <p class="text-content">El cuadro 1.6 muestra todos los métodos para redirección de entrada y salida, ya
                    explicados anteriormente, de <code>ProcessBuilder</code>.</p>

                <div class="table-container">
                    <h4 class="table-title">Cuadro 1.6 - Métodos de la clase ProcessBuilder para redirección de entrada
                        y salida</h4>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Método</th>
                                <th>Funcionalidad</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>ProcessBuilder inheritIO()</code></td>
                                <td>Redirige la salida estándar y de error de los subprocesos creados hacia las del
                                    proceso padre, y su entrada estándar desde la del proceso padre.</td>
                            </tr>
                            <tr>
                                <td><code>ProcessBuilder redirectInput(File f)</code><br>
                                    <code>ProcessBuilder redirectInput(</code><br>
                                    <code>ProcessBuilder.Redirect fuente)</code><br>
                                    <code>ProcessBuilder redirectOutput(File f)</code><br>
                                    <code>redirectOutput(</code><br>
                                    <code>ProcessBuilder.Redirect destino)</code><br>
                                    <code>ProcessBuilder redirectError(File f)</code><br>
                                    <code>redirectError(</code><br>
                                    <code>ProcessBuilder.Redirect destino)</code>
                                </td>
                                <td>Redirige las entrada y salida estándares y de error, respectivamente, desde o hacia:
                                    <ul>
                                        <li>Un fichero (con <code>File f</code>).</li>
                                        <li>La correspondiente del proceso padre (con <code>Redirect.INHERIT</code>).
                                        </li>
                                        <li>La salida estándar y de error se pueden descartar (con
                                            <code>Redirect.DISCARD</code>).
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td><code>ProcessBuilder redirectErrorStream(</code><br>
                                    <code>boolean redir)</code>
                                </td>
                                <td>Con valor <code>true</code> para <code>redir</code>, dirige la salida de error hacia
                                    la estándar. Esto hace innecesario gestionar por separado la salida de error. Tiene
                                    el inconveniente de que no se puede distinguir entre ambas. Pero tiene la ventaja de
                                    que evita que ambas aparezcan entremezcladas, lo que dificulta su lectura e
                                    interpretación.</td>
                            </tr>
                            <tr>
                                <td><code>static List&lt;Process&gt; startPipeline(</code><br>
                                    <code>List&lt;ProcessBuilder&gt; builders)</code>
                                </td>
                                <td>Inicia un proceso para cada <code>ProcessBuilder</code>, y crea una secuencia de
                                    procesos cuyas salida y entradas están enlazadas mediante tuberías o <em>pipes</em>,
                                    de manera que la salida de un proceso se dirige a la entrada del siguiente en la
                                    secuencia. Solo se pueden redirigir la entrada del primer proceso y la salida del
                                    último. El resto de entradas y salidas están conectadas mediante <em>pipes</em> de
                                    un proceso al siguiente y, obviamente, no se pueden redirigir.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h4 class="section-title">B) Mecanismos de redirección a streams de la clase Process</h4>

                <p class="text-content">La clase <code>Process</code> tiene métodos que devuelven <em>streams</em>
                    asociados a la entrada estándar del proceso, a la salida estándar y a la salida de error. Esto
                    permite enviar datos a la entrada estándar del proceso y leer de la salida estándar y de error, lo
                    que permite un absoluto control y flexibilidad, más allá de los sencillos mecanismos de redirección
                    vistos anteriormente.</p>

                <div class="table-container">
                    <h4 class="table-title">Cuadro 1.7 - Métodos de Process para obtener streams asociados a entrada
                        estándar y a salidas estándar y de error</h4>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Método</th>
                                <th>Funcionalidad</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>InputStream</code><br>
                                    <code>getInputStream()</code>
                                </td>
                                <td>Devuelve un <em>stream</em> de entrada conectado con la salida estándar del proceso.
                                </td>
                            </tr>
                            <tr>
                                <td><code>OutputStream</code><br>
                                    <code>getOutputStream()</code>
                                </td>
                                <td>Devuelve un <em>stream</em> de salida conectado con la entrada estándar del proceso.
                                </td>
                            </tr>
                            <tr>
                                <td><code>InputStream</code><br>
                                    <code>getErrorStream()</code>
                                </td>
                                <td>Devuelve un <em>stream</em> de entrada conectado con la salida de error del proceso.
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <p class="text-content">Sobre estos <em>streams</em> binarios se pueden construir <em>streams</em> de
                    texto (un <code>InputStreamReader</code> sobre un <code>InputStream</code>), y sobre estos se pueden
                    construir <em>streams</em> con <em>buffering</em>, que permiten leer o escribir líneas enteras.</p>

                <p class="text-content">El siguiente programa de ejemplo ejecuta un comando que se proporciona como
                    argumentos de línea de comandos. La salida del proceso se obtiene con
                    <code>p.getInputStream()</code>. Sobre el <code>InputStream</code> obtenido se construye un
                    <code>BufferedReader</code>, para poder obtener la salida como texto y línea a línea.
                </p>
            </div>
        </main>
    </div>
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="js/main.js"></script>
</body>

</html>