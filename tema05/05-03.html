<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TLS/SSL en Java</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div>TLS/SSL en Java</div>
    </header>

    <section class="contenido-didactico">
        <h1>TLS/SSL en Java</h1>

        <section class="intro-crypto">
            <h2>Introducción a TLS/SSL</h2>
            <p><strong>TLS</strong> (Transport Layer Security) y su predecesor <strong>SSL</strong> (Secure Sockets Layer) son protocolos criptográficos diseñados para proporcionar comunicaciones seguras a través de una red.</p>
            
            <h3>Evolución del Protocolo</h3>
            <ul>
                <li><strong>SSL 2.0</strong> (1995) - Obsoleto</li>
                <li><strong>SSL 3.0</strong> (1996) - Obsoleto</li>
                <li><strong>TLS 1.0</strong> (1999) - Deprecado</li>
                <li><strong>TLS 1.1</strong> (2006) - Deprecado</li>
                <li><strong>TLS 1.2</strong> (2008) - Ampliamente usado</li>
                <li><strong>TLS 1.3</strong> (2018) - Versión actual recomendada</li>
            </ul>
        </section>

        <h2>Configuración Básica de TLS</h2>
        
        <details>
            <summary>Qué es</summary>
            <p>Sistema de configuración que establece los parámetros básicos para crear conexiones seguras TLS, incluyendo la gestión de certificados y claves.</p>
        </details>

        <details>
            <summary>Por qué es necesario</summary>
            <ul>
                <li>Establecer conexiones seguras entre cliente y servidor</li>
                <li>Gestionar certificados digitales</li>
                <li>Configurar parámetros de seguridad</li>
                <li>Implementar cifrado en las comunicaciones</li>
            </ul>
        </details>

        <details>
            <summary>Funcionamiento</summary>
            <ol>
                <li>Carga el almacén de claves (KeyStore)</li>
                <li>Configura los gestores de claves y certificados</li>
                <li>Inicializa el contexto SSL con los parámetros seguros</li>
                <li>Implementa la configuración para el handshake TLS</li>
            </ol>
        </details>

        <pre><code class="language-java">import javax.net.ssl.*;
import java.security.*;

public class TLSConfig {
    public static SSLContext createSSLContext() throws Exception {
        // Crear KeyStore
        KeyStore keyStore = KeyStore.getInstance("PKCS12");
        keyStore.load(
            new FileInputStream("keystore.p12"),
            "password".toCharArray()
        );

        // Configurar KeyManagerFactory
        KeyManagerFactory kmf = KeyManagerFactory.getInstance(
            KeyManagerFactory.getDefaultAlgorithm()
        );
        kmf.init(keyStore, "password".toCharArray());

        // Configurar TrustManagerFactory
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(
            TrustManagerFactory.getDefaultAlgorithm()
        );
        tmf.init(keyStore);

        // Crear y configurar SSLContext
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(
            kmf.getKeyManagers(),
            tmf.getTrustManagers(),
            new SecureRandom()
        );

        return sslContext;
    }
}</code></pre>

        <h2>Proceso de Handshake TLS</h2>
        
        <details>
            <summary>Qué es</summary>
            <p>Proceso de negociación inicial entre cliente y servidor que establece los parámetros de seguridad y verifica la identidad de las partes.</p>
        </details>

        <details>
            <summary>Por qué es necesario</summary>
            <ul>
                <li>Establecer una conexión segura</li>
                <li>Verificar la identidad de las partes</li>
                <li>Negociar parámetros de cifrado</li>
                <li>Generar claves de sesión</li>
            </ul>
        </details>

        <details>
            <summary>Funcionamiento</summary>
            <ol>
                <li>Cliente envía ClientHello con capacidades de cifrado</li>
                <li>Servidor responde con certificado y parámetros</li>
                <li>Cliente verifica certificado y envía clave de sesión</li>
                <li>Ambas partes confirman establecimiento seguro</li>
            </ol>
        </details>

        <pre><code class="language-plaintext">Cliente                                     Servidor
   |                                           |
   |------- ClientHello ---------------------->|
   |                                           |
   |<------ ServerHello -----------------------|
   |<------ Certificate -----------------------|
   |<------ ServerKeyExchange -----------------|
   |<------ ServerHelloDone -------------------|
   |                                           |
   |------- ClientKeyExchange ---------------->|
   |------- ChangeCipherSpec ----------------->|
   |------- Finished ------------------------->|
   |                                           |
   |<------ ChangeCipherSpec ------------------|
   |<------ Finished --------------------------|
   |                                           |</code></pre>

        <h3>Implementación del Handshake</h3>
        
        <pre><code class="language-java">public class TLSHandshake {
    private SSLSocket createSecureSocket(String host, int port) 
            throws Exception {
        SSLContext context = TLSConfig.createSSLContext();
        SSLSocketFactory factory = context.getSocketFactory();
        
        SSLSocket socket = (SSLSocket) factory.createSocket(host, port);
        
        // Configurar protocolos permitidos
        socket.setEnabledProtocols(new String[] {"TLSv1.2", "TLSv1.3"});
        
        // Configurar cipher suites
        socket.setEnabledCipherSuites(
            getSecureCipherSuites(socket.getSupportedCipherSuites())
        );
        
        return socket;
    }

    private String[] getSecureCipherSuites(String[] supported) {
        List<String> secure = new ArrayList<>();
        for (String suite : supported) {
            // Seleccionar solo cipher suites seguros
            if (suite.contains("_GCM_") || 
                suite.contains("_CHACHA20_") ||
                suite.contains("_ECDHE_")) {
                secure.add(suite);
            }
        }
        return secure.toArray(new String[0]);
    }
}</code></pre>

        <h2>Gestión de Certificados</h2>
        
        <details>
            <summary>Qué es</summary>
            <p>Sistema para crear, gestionar y almacenar certificados digitales que son fundamentales para la autenticación y el cifrado en TLS.</p>
        </details>

        <details>
            <summary>Por qué es necesario</summary>
            <ul>
                <li>Generar certificados para autenticación</li>
                <li>Almacenar certificados de forma segura</li>
                <li>Gestionar claves públicas y privadas</li>
                <li>Implementar infraestructura de clave pública</li>
            </ul>
        </details>

        <details>
            <summary>Funcionamiento</summary>
            <ol>
                <li>Genera par de claves RSA</li>
                <li>Crea certificado autofirmado</li>
                <li>Configura información y extensiones del certificado</li>
                <li>Almacena certificado en KeyStore</li>
            </ol>
        </details>

        <pre><code class="language-java">public class CertificateManager {
    public static X509Certificate generateSelfSignedCertificate() 
            throws Exception {
        // Generar par de claves
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(2048);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();

        // Crear información del certificado
        X500Name issuer = new X500Name("CN=Test CA");
        X500Name subject = new X500Name("CN=Test Server");
        BigInteger serial = BigInteger.valueOf(System.currentTimeMillis());
        Date notBefore = new Date();
        Date notAfter = new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000L);

        // Crear generador de certificados
        X509v3CertificateBuilder certBuilder = new JcaX509v3CertificateBuilder(
            issuer,
            serial,
            notBefore,
            notAfter,
            subject,
            keyPair.getPublic()
        );

        // Añadir extensiones básicas
        certBuilder.addExtension(
            Extension.basicConstraints,
            true,
            new BasicConstraints(false)
        );

        // Firmar el certificado
        ContentSigner contentSigner = new JcaContentSignerBuilder("SHA256withRSA")
            .build(keyPair.getPrivate());

        return new JcaX509CertificateConverter()
            .getCertificate(certBuilder.build(contentSigner));
    }

    public static void storeCertificate(X509Certificate cert, 
            PrivateKey privateKey, String alias, String password) 
            throws Exception {
        KeyStore keyStore = KeyStore.getInstance("PKCS12");
        keyStore.load(null, null);

        keyStore.setKeyEntry(
            alias,
            privateKey,
            password.toCharArray(),
            new Certificate[]{cert}
        );

        try (FileOutputStream fos = new FileOutputStream("keystore.p12")) {
            keyStore.store(fos, password.toCharArray());
        }
    }
}</code></pre>

        <h2>Mejores Prácticas de TLS</h2>
        <ul>
            <li>Usar solo TLS 1.2 o superior</li>
            <li>Deshabilitar todos los cipher suites débiles</li>
            <li>Implementar Perfect Forward Secrecy (PFS)</li>
            <li>Validar certificados correctamente</li>
            <li>Mantener actualizadas las bibliotecas de seguridad</li>
            <li>Implementar HSTS en servidores web</li>
            <li>Usar longitudes de clave adecuadas</li>
        </ul>

        <h3>Configuración de Cipher Suites Recomendados</h3>
        <pre><code class="language-java">String[] recommendedCiphers = new String[] {
    "TLS_AES_256_GCM_SHA384",           // TLS 1.3
    "TLS_CHACHA20_POLY1305_SHA256",     // TLS 1.3
    "TLS_AES_128_GCM_SHA256",           // TLS 1.3
    "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
    "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
    "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
    "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
    "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
    "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"
};</code></pre>

        <h3>Dependencias Maven</h3>
        <pre><code class="language-xml">&lt;!-- Para soporte TLS adicional --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
    &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;
    &lt;version&gt;1.70&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Para manejo de certificados --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
    &lt;artifactId&gt;bcpkix-jdk15on&lt;/artifactId&gt;
    &lt;version&gt;1.70&lt;/version&gt;
&lt;/dependency&gt;</code></pre>

    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="script.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>
</body>
</html>