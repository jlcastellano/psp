<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programación de Hilos en Java - Clase Thread</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/vs2015.min.css">

</head>

<body>
    <header class="header">
        <div class="header-content">
            <div class="logo">Programación de Hilos en Java</div>
        </div>
    </header>
    <div class="container">
        <main>
            <div class="content-header">
                <h1 class="content-title">2.3. La Clase Thread</h1>
            </div>
            <section class="lesson-section">
                <h2 class="section-title">Métodos Principales de la Clase Thread</h2>
                <div class="text-content">
                    <p>La clase <code>Thread</code> proporciona la funcionalidad esencial para la creación, ejecución y
                        gestión de hilos. El siguiente cuadro resume los principales métodos de esta clase.</p>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>Método</th>
                            <th>Funcionalidad</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>void run()</td>
                            <td>Se ejecuta cuando se lanza el hilo. Es el punto de entrada del hilo, como el método
                                main() es el punto de entrada del proceso.</td>
                        </tr>
                        <tr>
                            <td>void start()</td>
                            <td>Lanza el hilo. La JVM crea el hilo y ejecuta su método run().</td>
                        </tr>
                        <tr>
                            <td>static void sleep(long ms)</td>
                            <td>Detiene la ejecución del hilo actualmente en ejecución durante un tiempo, que se puede
                                indicar en microsegundos.</td>
                        </tr>
                        <tr>
                            <td>static void sleep(long ms, long ns)</td>
                            <td>Detiene la ejecución del hilo actual durante un tiempo indicado en microsegundos y
                                nanosegundos.</td>
                        </tr>
                        <tr>
                            <td>void join()</td>
                            <td>Espera a que termine el hilo. Se puede indicar un tiempo máximo de espera.</td>
                        </tr>
                        <tr>
                            <td>void join(long ms)</td>
                            <td>Espera a que termine el hilo durante el tiempo indicado en milisegundos.</td>
                        </tr>
                        <tr>
                            <td>void join(long ms, long ns)</td>
                            <td>Espera a que termine el hilo durante un tiempo indicado en milisegundos y nanosegundos.
                            </td>
                        </tr>
                        <tr>
                            <td>void interrupt()</td>
                            <td>Interrumpe la ejecución de un hilo.</td>
                        </tr>
                        <tr>
                            <td>boolean isInterrupted()</td>
                            <td>Verifica si ha interrumpido la ejecución.</td>
                        </tr>
                        <tr>
                            <td>static boolean interrupted()</td>
                            <td>Verifica si se ha interrumpido la ejecución del hilo actual, y borra el estado de
                                interrupción.</td>
                        </tr>
                        <tr>
                            <td>boolean isAlive()</td>
                            <td>Comprueba si el hilo está vivo. Un hilo está vivo cuando se ha iniciado y no ha
                                terminado su ejecución.</td>
                        </tr>
                        <tr>
                            <td>int getPriority()</td>
                            <td>Obtiene la prioridad de un hilo.</td>
                        </tr>
                        <tr>
                            <td>void setPriority(int nuevaPrior)</td>
                            <td>Establece la prioridad de un hilo.</td>
                        </tr>
                        <tr>
                            <td>static Thread currentThread()</td>
                            <td>Devuelve un objeto de clase Thread correspondiente al hilo en ejecución actualmente.
                            </td>
                        </tr>
                        <tr>
                            <td>long getId()</td>
                            <td>Devuelve el identificador del hilo.</td>
                        </tr>
                        <tr>
                            <td>String getName()</td>
                            <td>Recupera el nombre del hilo.</td>
                        </tr>
                        <tr>
                            <td>void setName(String nombre)</td>
                            <td>Asigna un nombre al hilo.</td>
                        </tr>
                        <tr>
                            <td>Thread.State getState()</td>
                            <td>Devuelve el estado del hilo.</td>
                        </tr>
                        <tr>
                            <td>boolean isDaemon()</td>
                            <td>Verifica si el hilo es de tipo daemon.</td>
                        </tr>
                        <tr>
                            <td>void setDaemon(boolean on)</td>
                            <td>Configura si el hilo debe ser daemon o no.</td>
                        </tr>
                    </tbody>
                </table>

                <div class="text-content">
                    <p><strong>Nota sobre hilos daemon:</strong> Un hilo puede ser de tipo daemon. La distinción es
                        importante, porque la JVM termina su ejecución cuando no queda ningún hilo activo o cuando solo
                        quedan hilos de tipo daemon.</p>
                </div>
            </section>
            <section class="lesson-section">
                <h2 class="section-title">Programa con Pausas y Esperas</h2>
                <div class="text-content">
                    <p>El siguiente programa lanza dos hilos. Cada uno de ellos hace pausas de duración aleatoria de
                        entre 10 y 500 ms, utilizando el método <code>sleep</code> de la clase <code>Thread</code>. El
                        hilo principal utiliza el método <code>join</code> para esperar a que terminen los dos hilos
                        lanzados, por lo que siempre terminará el último.</p>

                    <p>Los métodos <code>sleep</code> y <code>join</code> paran la ejecución del hilo, y durante este
                        periodo de tiempo se podría interrumpir. Si esto sucede, se lanzará una
                        <code>InterruptedException</code>, que se captura para mostrar un mensaje.</p>
                </div>

                <div class="code-container">
                    <div class="code-header"><span>Ejemplo: LanzaHilosYAEsperarQueTerminen.java</span><span
                            class="language-badge">java</span></div>
                    <div class="code-content">
                        <button class="copy-button">Copiar</button>
                        <pre><code>import java.util.Random;

class Hilo implements Runnable {
  private final String nombre;

  Hilo(String nombre) {
    this.nombre = nombre;
  }

  @Override
  public void run() {
    System.out.printf("Hola, soy el hilo: %s.\n", this.nombre);
    Random r = new Random();
    for (int i = 0; i < 5; i++) {
      int pausa = 10 + r.nextInt(500 - 10);
      System.out.printf("Hilo: %s hace pausa de %d ms.\n", 
                        this.nombre, pausa);
      try {
        Thread.sleep(pausa);
      } catch (InterruptedException e) {
        System.out.println("Hilo " + this.nombre + " interrumpido.");
      }
    }
    System.out.printf("Hilo %s terminado.\n", this.nombre);
  }
}

public class LanzaHilosYAEsperarQueTerminen {
  public static void main(String[] args) {
    Thread h1 = new Thread(new Hilo("H1"));
    Thread h2 = new Thread(new Hilo("H2"));
    h1.start();
    h2.start();
    try {
      h1.join();
      h2.join();
    } catch (InterruptedException e) {
      System.out.println("Hilo principal interrumpido.");
    }
    System.out.println("Hilo principal terminado.");
  }
}</code></pre>
                    </div>
                </div>
            </section>
  <section class="lesson-section">
                <h2 class="section-title">Estados de un Hilo en Java</h2>
                <div class="text-content">
                    <p>En Java, los hilos pueden encontrarse en diferentes estados durante su ciclo de vida, definidos en el enumerado <code>Thread.State</code> accesible mediante el método <code>getState()</code> de la clase <code>Thread</code>. Estos estados permiten monitorear el comportamiento concurrente de los hilos, facilitando la comprensión y depuración de programas multi-hilo.</p>
                </div>

                <div class="table-responsive">
                    <table>
                        <thead>
                            <tr>
                                <th>Estado</th>
                                <th>Descripción</th>
                                <th>Condiciones de Transición</th>
                                <th>Ejemplo de Uso</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>NEW</td>
                                <td>El hilo ha sido creado mediante <code>new Thread(...)</code> pero aún no ha sido iniciado con <code>start()</code>. No consume recursos del sistema.</td>
                                <td>Se transita a RUNNABLE al llamar <code>start()</code>. Si nunca se inicia, permanece en NEW hasta la recolección de basura.</td>
                                <td><code>Thread t = new Thread(runnable); // Estado: NEW</code> – Útil para preparar hilos sin ejecutarlos inmediatamente.</td>
                            </tr>
                            <tr>
                                <td>RUNNABLE</td>
                                <td>El hilo está ejecutándose en la JVM o está listo para ejecutarse (en la cola de hilos del scheduler del SO). Incluye tiempo de ejecución real y tiempo listo.</td>
                                <td>Puede pasar a BLOCKED/WAITING/TIMED_WAITING por sincronización o sleep; a TERMINATED al finalizar <code>run()</code>.</td>
                                <td>Hilo en ejecución: <code>t.start(); // Estado: RUNNABLE</code> – Representa el estado activo en programación concurrente.</td>
                            </tr>
                            <tr>
                                <td>BLOCKED</td>
                                <td>El hilo está bloqueado esperando adquirir un monitor lock (bloqueo intrínseco) para entrar en un bloque <code>synchronized</code>. Ocurre en sincronización de métodos o bloques.</td>
                                <td>Transita a RUNNABLE al adquirir el lock. Común en accesos a recursos compartidos para evitar condiciones de carrera.</td>
                                <td>Esperando lock: <code>synchronized(obj) { ... } // Si lock ocupado: BLOCKED</code> – Previene accesos concurrentes no seguros.</td>
                            </tr>
                            <tr>
                                <td>WAITING</td>
                                <td>El hilo está esperando indefinidamente a que otro hilo invoque <code>notify()</code> o <code>notifyAll()</code> sobre el mismo objeto monitor. Libera el lock al entrar en este estado.</td>
                                <td>Transita a BLOCKED al intentar re-adquirir el lock tras notify, o a RUNNABLE si se interrumpe. Usado en patrones como productor-consumidor.</td>
                                <td><code>obj.wait(); // Estado: WAITING</code> – Para coordinación entre hilos, como esperar señales en colas compartidas.</td>
                            </tr>
                            <tr>
                                <td>TIMED_WAITING</td>
                                <td>Similar a WAITING, pero con un timeout: el hilo espera hasta que expire el tiempo o llegue una notificación. Incluye llamadas como <code>Thread.sleep()</code>, <code>Object.wait(timeout)</code>, <code>Thread.join(timeout)</code> o <code>Lock.lockInterruptibly()</code>.</td>
                                <td>Transita a RUNNABLE al expirar el timeout o recibir notify; puede interrumpirse. Útil para esperas con límite temporal.</td>
                                <td><code>Thread.sleep(1000); // Estado: TIMED_WAITING</code> – Evita esperas indefinidas en bucles concurrentes.</td>
                            </tr>
                            <tr>
                                <td>TERMINATED</td>
                                <td>El hilo ha completado su ejecución (método <code>run()</code> terminó) o ha sido interrumpido fatalmente. No puede reanudarse y sus recursos se liberan.</td>
                                <td>Estado final; no hay transiciones salientes. Verificar con <code>isAlive()</code> que retorne false.</td>
                                <td>Al finalizar <code>run(): // Estado: TERMINATED</code> – Indica fin de tarea en pools de hilos o monitores de progreso.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="text-content">
                    <p>Esta tabla resume los seis estados posibles, que son inmutables y se obtienen de forma atómica con <code>thread.getState()</code>, permitiendo un monitoreo no intrusivo en aplicaciones concurrentes. En la práctica, un hilo puede transitar rápidamente entre estados (por ejemplo, de RUNNABLE a BLOCKED en sincronizaciones frecuentes), lo que resalta la necesidad de un diseño robusto para evitar problemas como deadlocks o starvation.</p>
                </div>
            </section>            
        </main>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="js/main.js"></script>
</body>

</html>